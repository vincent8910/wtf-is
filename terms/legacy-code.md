# Legacy Code（遺留程式碼）— 上一任留下來的爛攤子

> **白話說：** Legacy Code 就像接手一間老房子——前屋主亂改管線，你不知道拆哪面牆會不會漏水。

---

## 它到底是什麼？

**Legacy** 原意是「遺產」，聽起來很正面。但在工程師口中，它幾乎等於：

> **「前人留下來的、沒人完全理解的舊程式碼。」**

```
前屋主的傑作：
├── 廚房的電線接到浴室的開關（？？？）
├── 牆壁裡有一條不知道通往哪的水管
├── 有一扇門被封死了，沒人知道為什麼
└── 裝潢圖紙？早就不見了
```

這間房子**能住嗎？能。** 但每次想動一個地方都提心吊膽——拆個櫃子，整面牆開始滲水。

## 為什麼不能全部打掉重寫？

| 想法 | 現實 |
|------|------|
| 「全部重寫比較快」 | 重寫可能要 6-12 個月，舊系統還得照跑 |
| 「我比前人聰明」 | 很多莫名其妙的寫法，其實在解決你沒碰過的問題 |
| 「重寫後一定更好」 | 新系統可能帶來新 bug |

所以大多數團隊選擇**漸進式改善**——一小塊一小塊整理（[Refactor](refactor.md)），而不是全部推倒重來。

## 日常場景

- **「這段 legacy code 沒人敢動」**
  → 程式碼很老很複雜，改了怕壞掉
- **「要在 legacy code 上加功能，風險很高」**
  → 要花更多時間測試，可能改了 A 壞了 B
- **「系統有很多 legacy 的包袱」**
  → [技術債](technical-debt.md) 很重，開發速度被拖慢

> 💡 理解 legacy code 可以幫你理解「為什麼看起來很簡單的功能要做很久」——因為工程師得先搞懂老房子的管線，才敢動手。

---

**[← 回到術語總覽](../README.md)** · **[了解技術債 →](technical-debt.md)** · **[了解 Refactor →](refactor.md)**
